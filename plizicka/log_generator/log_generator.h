#ifndef _LOG_GENERATOR
#define _LOG_GENERATOR

#include <string>
#include <stdbool.h>
#include <stdlib.h>

#define CURVE_STEP 2
#define CURVE_LENGTH 30
#define CURVE_MIN_Y 0
#define CURVE_MAX_Y 4

#define MIN_YEAR 2018
#define MAX_YEAR 2022
#define MIN_MONTH 1
#define MAX_MONTH 12
#define MIN_DAY 1
#define MAX_DAY_SHORT 30
#define MAX_DAY_LONG 31
#define MAX_DAY_NON_LAP 28
#define MAX_DAY_LAP 29

#define DOC_ID_LENGTH 10
#define LOG_ID_LENGTH 5

#define MIN_LOGS 100
#define MAX_LOGS 150

#define LOCATION_MIN_LETTER 'A'
#define LOCATION_MAX_LETTER 'Z'
#define LOCATION_MIN_NUM 1
#define LOCATION_MAX_NUM 26
#define LOCATION_MIN_COUNT 3
#define LOCATION_MAX_COUNT 6

int get_rand(int min, int max);

/**
 * @brief Date type { year, month, day }
 * 
 * @details
 * Methods:
 * to_string()
 * value()
 * init_random()
 */
struct date_t
{
    int year;
    int month;
    int day;

    //month types by day count
    enum Month_type { LONG, SHORT, LAP_DEPENDENT };
    //month lenghts
    const Month_type month_length[12] = { LONG, LAP_DEPENDENT, LONG, SHORT, LONG, SHORT, LONG, LONG, SHORT, LONG, SHORT, LONG };

    //to string in format DD/MM/YYYY
    public: std::string to_string()
    {
        return  std::to_string(year) + "/" + (month < 10 ? "0" : "") + std::to_string(month) + "/" + (day < 10 ? "0" : "") + std::to_string(day);
    }

    public: int value()
    {
        return (year - MIN_YEAR) * (365 + (is_lap() ? 1 : 0)) + month_days() + day;
    }

    private: int month_days()
    {
        int value = 0;
        for (uint8_t i = 0; i < month; i++)
        {
            switch (month_length[i])
            {
            case SHORT:
                value += MAX_DAY_SHORT;
                break;
            case LONG:
                value += MAX_DAY_LONG;
                break;
            case LAP_DEPENDENT:
                if (is_lap())
                    value += MAX_DAY_LAP;
                else
                    value += MAX_DAY_NON_LAP;
                break;
            default:
                //month_length is type Month_type {SHORT, LONG, LAP_DEPENDENT}
                throw std::exception();
                break;
            }
        }
        return value;
    }

    public: void init_random()
    {
        year = get_rand(MIN_YEAR, MAX_YEAR);
        month = get_rand(MIN_MONTH, MAX_MONTH);
        switch (month_length[month - 1])
        {
        case SHORT:
            day = get_rand(MIN_DAY, MAX_DAY_SHORT);
            break;

        case LONG:
            day = get_rand(MIN_DAY, MAX_DAY_LONG);
            break;

        case LAP_DEPENDENT:
            if (is_lap())
                day = get_rand(MIN_DAY, MAX_DAY_LAP);
            else
                day = get_rand(MIN_DAY, MAX_DAY_NON_LAP);
            break;

        default:
            //month_length is type Month_type {SHORT, LONG, LAP_DEPENDENT}
            throw std::exception();
            break;
        }
    }

    private: bool is_lap()
    {
        return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);
    }
};

/**
 * @brief Time type { h, m, s }
 * 
 * @details
 * Methods:
 * to_string()
 * value()
 * init_random()
 */
struct log_time_t
{
    uint8_t h;
    uint8_t m;
    uint8_t s;

    public: std::string to_string()
    {
        return (h < 10 ? "0" : "") + std::to_string(h) + ":" + (m < 10 ? "0" : "") + std::to_string(m) + ":" + (s < 10 ? "0" : "") + std::to_string(s);
    }

    public: int value()
    {
        return h * 3600 + m * 60 + s;
    }

    public: void init_random()
    {
        h = get_rand(0, 23);
        m = get_rand(0, 59);
        s = get_rand(0, 59);
    }
    
};

/**
 * @brief Curve type { points[CURVE_LENGTH] }
 * 
 * @details
 * stores y coords of curve (if generated by init_random(), then in range from CURVE_MIN_Y to CURVE_MAX_Y)
 * 
 * Methods:
 * to_latex()
 * init_random()
 */
struct curve_t
{
    uint8_t points[CURVE_LENGTH];

    /**
     * @brief initializes random values (from CURVE_MIN_Y to CURVE_MAX_Y) for all points
     * 
     */
    public: void init_random()
    {
        for (uint8_t i = 0; i < CURVE_LENGTH; i++)
        {
            points[i] = get_rand(CURVE_MIN_Y, CURVE_MAX_Y);
        }
    }

    /**
     * @brief returns latex code to draw the curve using tikz package
     * 
     * @return std::string curve code in tikz
     */
    public: std::string to_latex()
    {

        std::string out = "\\resizebox{0.33\\columnwidth}{!}{\n"
                          "\t\\begin{tikzpicture}\n"
                          "\t\t\\draw [draw=none] (0,0) -- (0,4);\t%%set height\n"
                          "\t\t\\draw [line width=2mm, black] plot [smooth, tension=0.7] coordinates { ";

        //write points
        for (uint8_t i = 0; i < CURVE_LENGTH; i++)
        {
            out += "(" + std::to_string(i * CURVE_STEP) + "," + std::to_string(points[i]) + ") ";
        }

        out += "};\n\t\\end{tikzpicture}}";

        return out;
    }
    /*output of this fnc

    \resizebox{!}{\fontheight}{
        \begin{tikzpicture}
            \draw [draw=none] (0,0) -- (0,4);   %set height
            \draw [line width=2mm, black] plot [smooth, tension=0.7] coordinates { "points (x,y)" };
        \end{tikzpicture}}
    */
};

struct coords_t
{
    char letter;
    int number;

    public: void init_random()
    {
        letter = get_rand(LOCATION_MIN_LETTER, LOCATION_MAX_LETTER);
        number = get_rand(LOCATION_MIN_NUM, LOCATION_MAX_NUM);
    }
};

struct locations_t
{
    uint8_t size;
    coords_t locations[LOCATION_MAX_COUNT];

    public: void init_random()
    {
        size = get_rand(LOCATION_MIN_COUNT, LOCATION_MAX_COUNT);

        for (uint8_t i = 0; i < size; i++)
        {
            locations[i].init_random();
        }
    }

    public: std::string to_string()
    {
        std::string out;
        out += locations[0].letter;
        out += std::to_string(locations[0].number);
        for (uint8_t i = 1; i < size; i++)
        {
            out += ", ";
            out += locations[i].letter;
            out += std::to_string(locations[i].number);
        }

        return out;
    }
};

/**
 * @brief Log type { id, date, time, curve, locations }
 * 
 */
struct log_t
{
    date_t date;
    log_time_t time;
    curve_t curve;
    locations_t locations;

    public: void init_random()
    {
        date.init_random();
        time.init_random();
        curve.init_random();
        locations.init_random();
    }
};

struct doc_t
{
    char id[DOC_ID_LENGTH + 1];
    unsigned int log_count;

    public: void init_random()
    {
        for (uint8_t i = 0; i < DOC_ID_LENGTH; i++)
        {
            id[i] = '0' + get_rand(0, 9);
        }
        id[DOC_ID_LENGTH] = '\0';
        log_count = get_rand(MIN_LOGS, MAX_LOGS);
    }
};


/**
 * @brief Get random value between ints including the bounds
 * 
 * @param min min value
 * @param max max value
 * @return min <= random_value <= max
 */
int get_rand(int min, int max)
{
    return rand() % (max - min + 1) + min;
}

#endif //_LOG_GENERATOR